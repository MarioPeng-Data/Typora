# 1分区表

分区表实际上就是对应一个HDFS文件系统上的独立的文件夹，该文件夹下是该分区所有的数据文件。**Hive中的分区就是分目录**，把一个大的数据集根据业务需要分割成小的数据集。在查询时通过 WHERE 子句中的表达式选择查询所需要的指定的分区，这样的查询效率会提高很多。

## 1.1 分区表的基本操作

（1）引入分区表（需要根据日期对日志进行管理）

```mysql
/user/hive/warehouse/log_partition/20170702/20170702.log
/user/hive/warehouse/log_partition/20170703/20170703.log
/user/hive/warehouse/log_partition/20170704/20170704.log
```

（2）创建分区表语法

```mysql
create table dept_partition(id int, name string, address string)
partitioned by (month string)
row format delimited fields terminated by '\t';
```

注意：分区字段不能是表中已经存在的数据，可以将分区字段看作表的伪列。

（3）加载数据到分区表中

```
load data inpath '/mario/hive/dept_partition/dept.txt' into table dept_partition partition(month='201709');
load data inpath '/mario/hive/dept_partition/dept.txt' into table dept_partition partition(month='201708');
load data inpath '/mario/hive/dept_partition/dept.txt' into table dept_partition partition(month='201707');
```

注意：分区表加载数据时，必须指定分区

![image-20210714222524207](https://gitee.com/peng-bo19951013/Picture/raw/master/20210715000323.png)

（4）查询分区表中数据

单分区查询

```mysql
select * from dept_partition where month='201709';
```

多分区联合查询

```mysql
select * from dept_partition where month='201709' union
select * from dept_partition where month='201708'union
select * from dept_partition where month='201707';
```

![image-20210714223734361](https://gitee.com/peng-bo19951013/Picture/raw/master/20210715000311.png)

（5）增加分区

创建单个分区

```mysql
alter table dept_partition add partition(month='201706') ;
```

同时创建多个分区

```mysql
alter table dept_partition add partition(month='201705') partition(month='201704');
```

（6）删除分区

删除单个分区

```
alter table dept_partition drop partition (month='201704');
```

同时删除多个分区

```
alter table dept_partition drop partition (month='201705'), partition (month='201706');
```

（7）查看分区表有多少分区

```
show partitions dept_partition;
```

（8）查看分区表结构

```
desc formatted dept_partition;
```

## 1.2分区表注意事项

（1）创建二级分区表

```mysql
create table dept_partition2(deptno int, dname string, loc string) 
partitioned by (month string, day string) 
row format delimited fields terminated by '\t';
```

（2）正常的加载数据

加载数据到二级分区表中

```mysql
load data inpath '/mario/hive/dept_partition/dept.txt' into table
dept_partition2 partition(month='201709', day='13');
```

查询分区数据

```mysql
select * from dept_partition2 where month='201709' and day='13';
```

（3）把数据直接上传到分区目录上，让分区表和数据产生关联的三种方式

方式一:上传数据后修复

- 上传数据

```mysql
hdfs dfs -mkdir -p /user/hive/warehouse/dept_partition2/month=201709/day=12;
hdfs dfs -put /opt/module/datas/dept.txt  /user/hive/warehouse/dept_partition2/month=201709/day=12;
```

- 查询数据（查询不到刚上传的数据）

```mysql
select * from dept_partition2 where month='201709' and day='12';
```

- 执行修复命令

```mysql
msck repair table dept_partition2;
```

- 再次查询数据

```mysql
select * from dept_partition2 where month='201709' and day='12';
```

方式二：上传数据后添加分区

- 上传数据

```
hdfs dfs -mkdir -p /user/hive/warehouse/dept_partition2/month=201709/day=11;
hdfs dfs -put /opt/module/datas/dept.txt  /user/hive/warehouse/dept_partition2/month=201709/day=11;
```

- 执行添加分区

```mysql
alter table dept_partition2 add partition(month='201709', day='11');
```

- 查询数据

```mysql
select * from dept_partition2 where month='201709' and day='11';
```

方式三：创建文件夹后load数据到分区

- 创建目录

```mysql
hdfs dfs -mkdir -p  /user/hive/warehouse/dept_partition2/month=201709/day=10;
```

- 上传数据

```mysql
load data inpath '/mario/hive/dept_partition/dept.txt' into table dept_partition2 partition(month='201709',day='10');
```

- 查询数据

```mysql
select * from dept_partition2 where month='201709' and day='10';
```

## 1.3 动态分区调整

关系型数据库中，对分区表Insert数据时候，数据库自动会根据分区字段的值，将数据插入到相应的分区中，Hive中也提供了类似的机制，即动态分区(Dynamic Partition)，只不过，使用Hive的动态分区，需要进行相应的配置。

开启动态分区参数设置

（1）开启动态分区功能（默认true，开启）

```
hive.exec.dynamic.partition=true
```

（2）设置为非严格模式（动态分区的模式，默认strict，表示必须指定至少一个分区为静态分区，nonstrict模式表示允许所有的分区字段都可以使用动态分区。）

```
hive.exec.dynamic.partition.mode=nonstrict
```

（3）在所有执行MR的节点上，最大一共可以创建多少个动态分区。默认1000

```
hive.exec.max.dynamic.partitions=1000
```

（4）在每个执行MR的节点上，最大可以创建多少个动态分区。该参数需要根据实际的数据来设定。比如：源数据中包含了一年的数据，即day字段有365个值，那么该参数就需要设置成大于365，如果使用默认值100，则会报错。

```
hive.exec.max.dynamic.partitions.pernode=100
```

（5）整个MR Job中，最大可以创建多少个HDFS文件。默认100000

```
hive.exec.max.created.files=100000
```

（6）当有空分区生成时，是否抛出异常。一般不需要设置。默认false

```
hive.error.on.empty.partition=false
```

案例实操：

（1）需求：将dept表中的数据按照地区（loc字段），插入到目标表dept_partition的相应分区中。

（2）创建目标分区表

```mysql
create table dept_partition(id int, name string)
partitioned by (location int) 
row format delimited fields terminated by '\t';
```

（3）设置动态分区

```
set hive.exec.dynamic.partition.mode = nonstrict;
```

```mysql
insert into table dept_partition 
partition(location) select deptno, dname, loc from dept;
```

（4）查看目标分区表的分区情况

```mysql
show partitions dept_partition;
```

思考：目标分区表是如何匹配到分区字段的？

# 2.分桶表

分区提供一个隔离数据和优化查询的便利方式。不过，并非所有的数据集都可形成合理的分区。对于一张表或者分区，Hive 可以进一步组织成桶，也就是更为细粒度的数据范围划分。

分桶是将数据集分解成更容易管理的若干部分的另一个技术。

**分区针对的是数据的存储路径；分桶针对的是数据文件。**

先创建分桶表，通过直接导入数据文件的方式

（1）数据准备

（2）创建分桶表

```mysql
create table stu_buck(id int, name string)
clustered by(id) 
into 4 buckets
row format delimited fields terminated by '\t';
```

（3）查看表结构

```mysql
desc formatted stu_buck;
#Num Buckets:   4   
```

（4）导入数据到分桶表中

```mysql
load data local inpath '/opt/module/datas/student.txt' into table stu_buck;
```

（5）查看创建的分桶表中是否分成4个桶

![image-20210716091101735](https://gitee.com/peng-bo19951013/Picture/raw/master/20210716091116.png)

（6）查询分桶的数据

```mysql
select * from stu_buck;
```

分桶规则：

根据结果可知：Hive的分桶采用对分桶字段的值进行哈希，然后除以桶的个数求余的方式决定该条记录存放在哪个桶当中。
